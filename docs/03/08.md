# 08、JDK 1.8中对hash算法和寻址算法是如何优化的

1) hash & (n-1) 和n取模,效果一样(要求数组的长度是2的n次方),但与运算性能好

2) 低16位融合了高16位和低16位的特征,避免了hash冲突

------------------------------

map.put(“张三”, “测试数据”)

 

对“张三”这个key计算他的hash值，是有一定的优化的

hash算法优化

```java
// JDK 1.8以后的HashMap里面的一段源码
static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```
 

比如说：有一个key的hash值

 

1111 1111 1111 1111 1111 1010 0111 1100

0000 0000 0000 0000 1111 1111 1111 1111

1111 1111 1111 1111 0000 0101 1000 0011 -> int值，32位

 

hash值一样 -> 他们其实都会在数组里放在一个位置，进行复杂的hash冲突的处理

 

[16个元素] -> hash值对数组长度取模，定位到数组的一个位置，塞进去就ok了

 

高低16位都参与运算

 

寻址算法优化

 

(n - 1) & hash -> 数组里的一个位置

 

1111 1111 1111 1111 1111 1010 0111 1100（没有经过优化的hash值）

0000 0000 0000 0000 0000 0000 0000 1111

 

取模运算，他是性能比较差一些，为了优化这个数组寻址的过程

 

hash & (n - 1) -> 效果是跟hash对n取模，效果是一样的，但是与运算的性能要比hash对n取模要高很多，数学问题，数组的长度会一直是2的n次方，只要他保持数组长度是2的n次方

 

hash对n取模的效果 -> hash & (n - 1)，效果是一样的，后者的性能更高

 

1111 1111 1111 1111 1111 1010 0111 1100（没有经过优化的hash值）

0000 0000 0000 0000 0000 0000 0000 1111

 

相当于，你直接这么搞，高16位之间的与运算，是可以忽略的，核心点在于低16位的与运算，hash值的高16位没有参与到与运算里来啊

 

假设有两个hash值

 

1111 1111 1111 1111 1111 1010 0111 1100 -> 1111 1111 1111 1111 0000 0101 1000 0011

1111 1111 1111 1110 1111 1010 0111 1100 -> 1111 1111 1111 1110 0000 0101 1000 0010

 

1111 1111 1111 1111 0000 0101 1000 0011（经过优化和二进制位运算的新的hash值）

0000 0000 0000 0000 0000 0000 0000 1111

 

 

配合起来讲

 

hash算法的优化：对每个hash值，在他的低16位中，让高低16位进行了异或，让他的低16位同时保持了高低16位的特征，尽量避免一些hash值后续出现冲突，大家可能会进入数组的同一个位置

 

寻址算法的优化：用与运算替代取模，提升性能
