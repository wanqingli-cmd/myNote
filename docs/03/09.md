hash冲突问题，链表+红黑树，O(n)和O(logn)

 

map.put和map.get -> hash算法优化（避免hash冲突），寻址性能优化

 

算出key的hash值，到数组中寻址，找到一个位置，把key-value对放进数组，或者从数组里取出来

 

两个key，多个key，他们算出来的hash的值，与n-1，与运算之后，发现定位出来的数组的位置还是一样的，hash碰撞，hash冲突

 

[<> -> <> -> <>, ]

 

array[0]这个位置，就是一个链表

 

会在这个位置挂一个链表，这个链表里面放入多个元素，让多个key-value对，同时放在数组的一个位置里

 

get，如果定位到数组里发现这个位置挂了一个链表，此时遍历链表，从里面找到自己的要找的那个key-value对就可以了

 

假设你的链表很长，可能会导致遍历链表，性能会比较差，O(n)

 

优化，如果链表的长度达到了一定的长度之后，其实会把链表转换为红黑树，遍历一颗红黑树找一个元素，此时O(logn)，性能会比链表高一些