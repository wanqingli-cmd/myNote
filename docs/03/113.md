# 113、唯一id生成机制中的snowflake算法的时钟回拨问题如何解决？ 
 
 回答: 比较容易理解的方案，如果发生了时钟回拨，确定时钟回拨到了之前的哪一毫秒里去，直接接着在那一毫秒里的最大的id继续自增就可以

 snowflake
  
   
  
  一串数字，用很多的二进制里的bit位，去代表不同的东西
  
   
  
  40多位都是当前机器上的时间，中间有几位是代表的是机器id，自增长的id
  
   
  
  分布式业务系统，分布在很多台机器上，这很多台机器都要生成唯一的id，不能重复，此时可以调用某台机器上的snowflake算法生成的唯一id
  
   
  
  12:00:00 500 28 1~20
  
   
  
  12:00:04 300 28 1~20
  
   
  
  12:00:05 308，当前你的snowflake算法部署的机器发生了本地时钟的回拨，时间回拨到了12:00:00 500这个时间
  
   
  
  判断是否发生了时钟回拨，当前时间比我上一次生成id的时间要小，此时就是发生了时钟回拨问题，12:00:00 500 28 1~20，snowflake算法生成的不重复的id，此时会导致生成的id是重复的，这就比较坑了
  
   
  
  比较简单容易理解的思路，当前的机器的可能会跟一台基准时间服务器进行时间校准，导致你的机器的时间本来跑的稍微快了一点，此时跟基准时间服务器进行了校准，你的时间回拨回去了，倒退回去了
  
   
  
  你在内存里把过去1个小时之内生成的每一毫秒的每台机器生成的id都在内存里保存最大的那个id
  
   
  
  12:00:00 500 28 20
  
  12:00:04 300 28 8
  
   
  
  如果发生了时钟回拨，此时你看看时钟回拨到了之前的哪一毫秒里去，直接接着在那一毫秒里的最大的id继续自增就可以了，12:00:00 500 28 21

-------------------------------
个人笔记:

[Tinyid：滴滴开源千万级并发的分布式ID生成器](https://mp.weixin.qq.com/s/P6LG8HQpQ1og3eIuNKQcYw)

[百度开源的分布式 ID 服务是如何解决时钟回拨问题的？](snowflake/UidGenerator.md)

面试题: 唯一id如何实现的，snowflake实现原理，snowflake有哪些问题，如何避免根据订单号可以推算出今天的订单量

### 订单号生成
[订单号的生成规则和不同生成策略](https://blog.csdn.net/qq_39597203/article/details/86504239)

淘宝订单号的生成规则
1. 总共18位
2. 前14位为序号
3. 15-16位买家ID的倒数1-2位
4. 17-18位买家ID的倒数3-4位

