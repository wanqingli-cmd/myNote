# 71、可见性涉及的底层硬件概念：寄存器、高速缓存、写缓冲器（上）

![可见性在硬件级别的说明](images/71/01.png)

![可见性在硬件级别的说明2](images/71/02.png)

从硬件的级别来考虑一下可见性的问题

 

每个处理器都有自己的寄存器（register），所以多个处理器各自运行一个线程的时候，可能导致某个变量给放到寄存器里去，接着就会导致各个线程没法看到其他处理器寄存器里的变量的值修改了

 

可见性的第一个问题，首先，就有可能在寄存器的级别，导致变量副本的更新，无法让其他处理器看到

 

然后一个处理器运行的线程对变量的写操作都是针对写缓冲来的（store buffer）并不是直接更新主内存，所以很可能导致一个线程更新了变量，但是仅仅是在写缓冲区里罢了，没有更新到主内存里去

 

这个时候，其他处理器的线程是没法读到他的写缓冲区的变量值的，所以此时就是会有可见性的问题，这是第二个可见性发生的场景

 

然后即使这个时候一个处理器的线程更新了写缓冲区之后，将更新同步到了自己的高速缓存里（cache，或者是主内存），然后还把这个更新通知给了其他的处理器，但是其他处理器可能就是把这个更新放到无效队列里去，没有更新他的高速缓存

 

此时其他处理器的线程从高速缓存里读数据的时候，读到的还是过时的旧值

 

可见性发生的问题

 

如果要实现可见性的话，其中一个方法就是通过MESI协议，这个MESI协议实际上有很多种不同的时间，因为他不过就是一个协议罢了，具体的实现机制要靠具体底层的系统如何实现

 

根据具体底层硬件的不同，MESI协议的实现是有区别的

 

比如说MESI协议有一种实现，就是一个处理器将另外一个处理器的高速缓存中的更新后的数据拿到自己的高速缓存中来更新一下，这样大家的缓存不就实现同步了，然后各个处理器的线程看到的数据就一样了

 

为了实现MESI协议，有两个配套的专业机制要给大家说一下：flush处理器缓存、refresh处理器缓存。

 

flush处理器缓存，他的意思就是把自己更新的值刷新到高速缓存里去（或者是主内存），因为必须要刷到高速缓存（或者是主内存）里，才有可能在后续通过一些特殊的机制让其他的处理器从自己的高速缓存（或者是主内存）里读取到更新的值

 

除了flush以外，他还会发送一个消息到总线（bus），通知其他处理器，某个变量的值被他给修改了

 

refresh处理器缓存，他的意思就是说，处理器中的线程在读取一个变量的值的时候，如果发现其他处理器的线程更新了变量的值，必须从其他处理器的高速缓存（或者是主内存）里，读取这个最新的值，更新到自己的高速缓存中

 

所以说，为了保证可见性，在底层是通过MESI协议、flush处理器缓存和refresh处理器缓存，这一整套机制来保障的

 

要记住，flush和refresh，这两个操作，flush是强制刷新数据到高速缓存（主内存），不要仅仅停留在写缓冲器里面；refresh，是从总线嗅探发现某个变量被修改，必须强制从其他处理器的高速缓存（或者主内存）加载变量的最新值到自己的高速缓存里去

 

内存屏障的使用，在底层硬件级别的原理，其实就是在执行flush和refresh，MESI协议是如何与内存屏障搭配使用的（flush、refresh）

 

volatile boolean isRunning = true;

 

isRunning = false; => 写volatile变量，就会通过执行一个内存屏障，在底层会触发flush处理器缓存的操作；while(isRunning) {}，读volatile变量，也会通过执行一个内存屏障，在底层触发refresh操作

 

之前给大家讲过那个volatile关键字的作用，对一个变量加了volatile修饰之后，对这个变量的写操作，会执行flush处理器缓存，把数据刷到高速缓存（或者是主内存）中，然后对这个变量的读操作，会执行refresh处理器缓存，从其他处理器的高速缓存（或者是主内存）中，读取最新的值

 

当然跟我们之前说的有一点点不一样，因为之前说的是写volatile变量的时候，一个是强制刷主内存，一个是过期掉其他处理器的高速缓存中的数据；读volatile变量的时候，会发现高速缓存中的值过期，然后强制从主内存加载最新值

 

其实这个东西吧，你没发现么，效果是一样的，他其实本质都是让一个线程写了volatie变量之后，另外一个变量立马可以读到volatile变量的值，只不过MESI协议的底层具体实现，根据cpu等硬件的不同，有多种不同的实现方式罢了



















写缓冲器 ,无效化队列 存储屏障 加载屏障
为什么会有写缓冲器 ,无效化队列 ？

先来看一下什么是缓存一致性协议

核心思想:如果变量是共享变量，当其他CPU修改这个变量的时候，发出信号将其他CPU的变量置为失效状态，其他CPU再使用这一变量的时候会从内存中加载这一变量。

修改共享数据的时候,发现相应 缓存行的状态是S, 就是共享,说明其他cpu也有副本, 这时候要发 无效 的通知出去广播给其他cpu把缓存里面的值为无效(Invalid)状态，然后待收到各个缓存的（Invalid ack）已经完成无效状态修改的回应之后，再把自己的状态改为Exclusive，之后再进行修改,修改后再改为Modified状态，数据写入缓存行。

这样会有一个缺点，CPU需要在等待所有的Invalid ack之后才会进行下面的操作。这会让CPU产生一定的阻塞，无法充分利用CPU。这个时候就出来了写缓冲器和无效队列化。

 写缓冲器

写的时候,发现相应 缓存行的状态是S, 就是共享,说明其他cpu也有副本, 这时候要发 无效 的通知出去广播给其他cpu把缓存里面的值为无效(Invalid)状态 本来是要等回复才能继续的, 有了写缓冲器 就可以先把修改的数据放到写缓冲器,然后通知等其他cpu等他们回复(ack), 这个时候不会造成线程阻塞，cpu可以利用等待的时间继续向下执行，等回复都到了以后cpu再来把数据从写缓冲器搬运到缓存行。
 
存储转发
cpu读取数据的时候先从 写缓存器读, 没有 再去 读高速缓存, 这样就可以还是读到真的数据了
无效化队列

其他cpu收到无效通知以后, 并不把数据无效化, 而是存入无效化队列 就回复 收到无效Ack,这样可以让对方早点收到回复，等cpu忙完当前的事在进行读取无效化队列。

这样会造成一些问题

存储转发:cpu0 更新了a的值, 写到写缓冲器就往下走了，过一阵,要读a，这时先去写缓存器读, 读到的自以为是最新的,但是没准这一阵时间里面, cpu1已经改过a的值了,但是, cpu1发过来的无效通知, 是管不到 cpu0的写缓冲器的。
写缓冲器:其他CPU还没有给我们回答的时候我们已经执行下一步代码了。
无效化队列:其他CPU已经给对方应答的时候自己本身还没有去把这个值改为无效状态,这样就造成当前变量已经无效，但是通知还在无效队列化中，会取到旧值。
存储屏障 加载屏障 

总之, 写缓冲器 ,无效化队列 就是导致了可见性问题, 明明写了 其他线程看不到这就需要编译器等底层系统 借助 内存屏障

存储屏障 : 让cpu 将 写缓冲器排空,写入高速缓存 这叫冲刷, 这样其他cpu 就会收到通知, 其他cpu可以来拿新数据
加载屏障:cpu 根据无效化队列里面的信息,删除其高速缓存的无效数据(就是状态变为I)

这2个屏障的成对使用, 才能保证更新可见
